package com.djj.languagepoints.chapter8.solidrule;

/**
 * Created by djj on 2018/10/17.
 * SOLID 原则是设计面向对象程序时的一些基本原则
 *
 * Single responsibility
 * 单一功能原则,程序中的类或方法只能有一个改变的理由。
 * 当软件的需求发生变化，实现这些功能的类和方法也需要变化。
 * 如果你的类有多个功能，一个功能引发的代码变化会影响该类的其他功能。
 * 这可能会引入缺陷，还会影响代码演进的能力。
 *
 * 单一功能原则不止于此：一个类不仅要功能单一，而且还需将功能封装好。
 * 换句话说，如果我想改变输出格式，那么只需改动负责输出的类，而不必关心负责制表的类。
 *
 * 利用高阶函数，可以轻松帮助实现功能单一原则.
 *
 * Open/closed
 * 开闭原则 软件应该对扩展开放，对修改闭合
 *
 * 让软件易于修改。一个新增功能或一处改动，会影响整个代码，容易引入新的缺陷。
 * 开闭原则保证已有的类在不修改内部实现的基础上可扩展
 *
 * 不改变实现怎么能扩展一个类的功能呢？答案是借助于抽象，可插入新的功能。
 *
 * Liskov substitution
 * Interface segregation
 *
 * Dependency inversion
 * 依赖反转原则
 *
 * 抽象不应依赖细节，细节应该依赖抽象。
 *
 * 依赖反转原则的目的是让程序员脱离底层粘合代码，编写上层业务逻辑代码。
 * 这就让上层代码依赖于底层细节的抽象，从而可以重用上层代码。
 * 这种模块化和重用方式是双向的：既可以替换不同的细节重用上层代码，也可以替换不同的业务逻辑重用细节的实现。
 *
 * 很多高阶函数都符合依赖反转原则。比如 map 函数重用了在两个集合之间转换的代码。
 * map 函数不依赖于转换的细节，而是依赖于抽象的概念。在这里，就是依赖函数接口： Function 。
 *
 * 高阶函数提供了反转控制，这就是依赖反转的一种形式，可以很容易地和Lambda 表达式一起使用。
 * 依赖反转原则另外值得注意的一点是待依赖的抽象不必是接口。
 */
public class SOLIDRule {

}
